# 1：delegatecall 跟 call 的区别是什么
## call是直接调用某个合约，修改该合约的数据，msg.sender是当前合约。
## delegatecall是调用某个合约来修改当前合约的数据，msg.sender是调用当前合约的地址。

# 2：可升级合约的执行流程是什么（user -> proxy -> implementation）
## 用户访问代理合约(proxy)，代理合约通过fallback函数delegatecall具体实现的逻辑合约（implementation）

# 3：代理合约上本身是有存储的，怎么避免跟逻辑合约上的存储产生冲突
## 有两个方法。第一种是在逻辑合约上冗余一份和代理合约一样顺序的存储。第二种是代理合约使用逻辑合约几乎不会使用的slot存储
```solidity 
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract EIP1967Proxy {
    // 1. 定义EIP-1967的固定slot（仅代理使用）
    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
    bytes32 private constant ADMIN_SLOT = bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);

    // 2. 代理仅操作这些slot，不定义其他存储变量
    constructor(address implementation, address admin) {
        // 存逻辑合约地址到专属slot
        _setSlot(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation))));
        // 存管理员地址到专属slot
        _setSlot(ADMIN_SLOT, bytes32(uint256(uint160(admin))));
    }

    // 底层存储操作：仅操作上述slot
    function _setSlot(bytes32 slot, bytes32 value) private {
        assembly {
            sstore(slot, value)
        }
    }

    // 代理转发逻辑（核心，不涉及存储）
    fallback() external payable {
        address impl = address(uint160(uint256(_getSlot(IMPLEMENTATION_SLOT))));
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) }
        }
    }

    function _getSlot(bytes32 slot) private view returns (bytes32) {
        assembly {
            let value := sload(slot)
            mstore(0, value)
            return(0, 32)
        }
    }
}```

# 4： 逻辑合约升级的存储冲突问题
## 历史版本的合约在storage slot顺序上要一致。只能往后累加，前面的不能改

# 5： 可以在逻辑合约的构造函数中初始化变量吗？为什么
## 不能，constructor会在逻辑合约部署时被执行了，此时修改的是逻辑合约的状态。正常做法是定义initialize，通过代理合约调用initialize