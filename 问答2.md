# 1：delegatecall 跟 call 的区别是什么
## call是直接调用某个合约，修改该合约的数据，msg.sender是当前合约。
## delegatecall是调用某个合约来修改当前合约的数据，msg.sender是调用当前合约的地址。

# 2：可升级合约的执行流程是什么（user -> proxy -> implementation）
## 用户访问代理合约(proxy)，代理合约通过fallback函数delegatecall具体实现的逻辑合约（implementation）

# 3：代理合约上本身是有存储的，怎么避免跟逻辑合约上的存储产生冲突
## 有两个方法。第一种是在逻辑合约上冗余一份和代理合约一样顺序的存储。第二种是代理合约使用逻辑合约几乎不会使用的slot存储
```solidity 
contract Proxy {
    bytes32 private constant IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    constructor(address _impl) {
        assembly {
            sstore(IMPLEMENTATION_SLOT, _impl)
        }
    }

    fallback() external payable {
        address impl;
        assembly {
            impl := sload(IMPLEMENTATION_SLOT)
        }
        (bool ok, ) = impl.delegatecall(msg.data);
        require(ok);
    }
}
```


# 4： 逻辑合约升级的存储冲突问题
## 历史版本的合约在storage slot顺序上要一致。只能往后累加，前面的不能改

# 5： 可以在逻辑合约的构造函数中初始化变量吗？为什么
## 不能，constructor会在逻辑合约部署时被执行了，此时修改的是逻辑合约的状态。正常做法是定义initialize，通过代理合约调用initialize